\hypertarget{simple-python-tk-two-link-simulator}{%
\section{Simple Python Tk Two Link
Simulator}\label{simple-python-tk-two-link-simulator}}

Note

Check to see if this will work with ROS2. Provide both.

You can download the TwoLink simulator by following the links on
\texttt{roboscience.org}. To get started, again you need to be in your
Ubuntu session and run the ROS Master:

\begin{verbatim}
>  roscore
\end{verbatim}

You can run the Two Link Manipulator simulator we will use by typing

\begin{verbatim}
>  python twolinksimple.py
\end{verbatim}

and you should see what is indicated in
\texttt{Fig:twolinksimulator1}-(a). In another terminal, run Python and
type

\begin{verbatim}
>>> import rospy
>>> from std_msgs.msg import String
>>> pub = rospy.Publisher('TwoLinkTheta', String, queue_size=10)
>>> rospy.init_node('talker', anonymous=True)
>>> message = "20:10:0"
>>> pub.publish(message)






The two link simulator.







Published angle to the simulator.
\end{verbatim}

You should see the link arm move as shown in
\texttt{Fig:twolinksimulator2}. The API is very simple. You need to
publish a string formatted as "theta1:theta2:pen". The values theta1 and
theta2 are in degrees (int or float), and pen is an int. Pen is set to 1
to draw and 0 to not draw. The program DialCntrl.py is an example of a
Tk widget that uses two sliders to set the angle,
\texttt{Fig:tksliderexample} (a). To gain an understanding of the ROS
Node structure, one may list out the ROS nodes (example, your numbers
will vary):

\begin{verbatim}
rosnode list
/DialController_5943_1473004072330
/TwoLinkSimulation_5785_1473004028541
/rosout
\end{verbatim}

To view the resulting node graph we can use the ROS tool rqt\_graph:

\begin{verbatim}
rosrun rqt_graph rqt_graph
\end{verbatim}

In this case it produces \texttt{Fig:rosgraph0}.

\begin{quote}
The ROS Node Graph Tool rqt\_graph.
\end{quote}

If you are curious about the messages flowing on a topic, recall ROS can
echo those to a terminal for debugging purposes. In a free terminal,
type

\begin{verbatim}
rostopic echo /TwoLinkTheta
\end{verbatim}

The move one of the sliders. You will see the message on the
TwoLinkTheta topic echoed. If you have source code you can clearly print
out the messages. It is nice to see what is actually going across. If
you don't have source code, then this tool is very handy.

A Tk control that can set position is given in the next example
PositionCntrl.py and shown in \texttt{Fig:tksliderexample} (b). The
widget PositionCntrl.py publishes \((x,y)\) coordinates. An intermediate
node IK.py is used to convert the \((x,y)\) values to
\((\theta_1, \theta_2)\) and these values are published to the Two Link
Simulator.

\begin{quote}
The servo angle control widget

The position control widget
\end{quote}

\begin{verbatim}
# Libraries
from math import *
import rospy
from std_msgs.msg import String
\end{verbatim}

\begin{verbatim}
# Call back function
def capture(data):
    var = data.data.split(":")
    x = float(var[0])
    y = float(var[1])
    a1 = float(var[2])
    a2 = float(var[3])
    pen = int(var[4])
    inverse(x,y,a1,a2,pen)
\end{verbatim}

\begin{verbatim}
# Compute IK and send to simulator
def inverse(x,y,a1,a2,pen):
    if (sqrt(x*x+y*y) > a1+a2):
      print "(x,y) out of reach for links"
    else:
      d =  (x*x+y*y-a1*a1-a2*a2)/(2.0*a1*a2)
      t2 = atan2(-sqrt(1.0-d*d),d)
      t1 = atan2(y,x) - atan2(a2*sin(t2),a1+a2*cos(t2))
      dt1 = (180.0*t1/pi)
      dt2 = (180.0*t2/pi)
      print x,y, dt1, dt2
      sliders = str(dt1) + ':' + str(dt2) + ':' + str(pen)
      pub.publish(sliders)
\end{verbatim}

\begin{verbatim}
# ROS management
pub = rospy.Publisher('TwoLinkTheta', String, queue_size=10)
rospy.init_node('Converter', anonymous=True)
rospy.Subscriber("TwoLinkCoords", String, capture)
rospy.spin()







The ROS Node Graph Tool rqt_graph.
\end{verbatim}

\hypertarget{animation-of-the-two-link-manipulator}{%
\section{Animation of the Two Link
Manipulator}\label{animation-of-the-two-link-manipulator}}

For the arm in the two link example, determine the joint angles to trace
out a circle centered at (10,8) of radius 5. The circle can be
parametrized by \(x(t) = 5\cos (t) + 8\), \(y(t) = 3 \sin(t) + 10\),
\(-\pi \leq t \leq \pi\). Generate an array of points on the circle and
plug them into the inverse kinematics.

Bring up the two link simulator. Then run the following code in Python.
You should see an animation of the two link arm drawing a circle. The
final position is given in \texttt{Fig:twolinkcircleexample}.

\begin{verbatim}
# Bring in libraries
import rospy
from std_msgs.msg import String
import numpy as np
import time
from math import *
\end{verbatim}

\begin{verbatim}
#Setup Arrays
step = 0.1
t = np.arange(-pi, pi, step)
x = 5.0*np.cos(t) + 8.0
y = 3.0*np.sin(t) + 10.0
\end{verbatim}

\begin{verbatim}
#Initialize variables
a1 = 10.0
a2 = 10.0
d = (x*x + y*y - a1*a1 - a2*a2)/(2*a1*a2)
t2 = np.arctan2(-np.sqrt(1.0-d*d),d)
t1 = np.arctan2(y,x) - np.arctan2(a2*np.sin(t2),a1+a2*np.cos(t2))
\end{verbatim}

\begin{verbatim}
# Setup ROS and publish joint data
pub = rospy.Publisher('TwoLinkTheta', String, queue_size=10)
rospy.init_node('talker', anonymous=True)

for i in range(t.size):
   print t1[i], "  ", t2[i]
   m = str(180*t1[i]/np.pi) + ":" + str(180*t2[i]/np.pi) + ":" + str(1)
   time.sleep(0.25)
   pub.publish(m)






The output of the circle inverse kinematics
code.
\end{verbatim}

In this example, we generate an array named t which is used for the
parametric equations of the circle to generate the x and y arrays. We
may use the inverse kinematic formulas to determine the arrays for
\(\theta_1\) and \(\theta_2\) called t1 and t2. The \(\theta_1\) and
\(\theta_2\) would be the values sent to the joint actuators.
\texttt{Fig:twolinkcircleexample} shows the results.

You can modify the data arrays to plot a line:

\begin{verbatim}
#Setup Arrays
t = np.arange(-5, 8, step)
x = t
y = x + 5
\end{verbatim}

The inverse kinematics can be placed into a separate ROS node. The
driving program follows (same headers as before). To connect to the
simulation program, we use the inverse kinematics node as before

\begin{verbatim}
#Setup Arrays
a1 = 10
a2 = 10
step = 0.1
t = np.arange(-pi, pi, step)
x = 5.0*np.cos(t) + 8.0
y = 3.0*np.sin(t) + 10.0

pub = rospy.Publisher('TwoLinkCoords', String, queue_size=10)
rospy.init_node('talker', anonymous=True)

for i in range(t.size):
   locs = str(x[i]) + ":" + str(y[i]) + ":" + str(10) + ":" + str(10)
                   +":" + str(1)
   time.sleep(0.25)
   pub.publish(locs)






Movement between the points - moving both linearly.







Movement between the points - moving the servos sequentially.
\end{verbatim}

This simulation gives an idea about how to move the robotic arm and the
path is correct. The motion however is not smooth. This is because we
are moving the arm from position to position. This is known as position
control. If you look at the curve produced, it is not a smooth curve but
is a curve made of of connected segments like a polygon,
\texttt{Fig:twolinkcoarseexample1}. Note that the output is not actually
a polygon; the sides are not straight line segments.

In between the control points, the system moves according to how the
controllers are programmed. They will move the joint angles in a linear
fashion. If they are moved together you will see
\texttt{Fig:twolinkcoarseexample1}. If they are moved one at a time you
will see \texttt{Fig:twolinkcoarseexample2}.
